<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Under the Hood: Unpacking Git's Secrets (Part 2)</title>
  <style>
    :root {
      --primary-blue: #3498db;
      --secondary-blue: #2980b9;
      --accent-orange: #f39c12;
      --accent-green: #27ae60;
      --accent-red: #e74c3c;
      --dark-text: #2c3e50;
      --light-gray: #ecf0f1;
      --medium-gray: #bdc3c7;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.7;
      color: var(--dark-text);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .header {
      background: linear-gradient(135deg, var(--primary-blue), var(--secondary-blue));
      color: white;
      padding: 60px 40px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .header::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: repeating-linear-gradient(45deg,
          transparent,
          transparent 10px,
          rgba(255, 255, 255, 0.05) 10px,
          rgba(255, 255, 255, 0.05) 20px);
      animation: slide 20s linear infinite;
    }

    @keyframes slide {
      0% {
        transform: translateX(-50px);
      }

      100% {
        transform: translateX(50px);
      }
    }

    .header h1 {
      font-size: 2.5em;
      font-weight: 700;
      margin-bottom: 10px;
      position: relative;
      z-index: 1;
    }

    .header .subtitle {
      font-size: 1.2em;
      opacity: 0.9;
      position: relative;
      z-index: 1;
    }

    .content {
      padding: 40px;
    }

    .section {
      margin-bottom: 50px;
    }

    .section h2 {
      color: var(--dark-text);
      font-size: 1.8em;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 3px solid var(--accent-orange);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .section h3 {
      color: var(--secondary-blue);
      font-size: 1.4em;
      margin: 30px 0 15px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon {
      width: 32px;
      height: 32px;
      background: var(--accent-orange);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
    }

    .library-analogy {
      background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
      border-radius: 15px;
      padding: 30px;
      margin: 30px 0;
      position: relative;
      overflow: hidden;
    }

    .library-visual {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin: 20px 0;
    }

    .books-chaotic,
    .books-organized {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }

    .book {
      display: inline-block;
      width: 12px;
      height: 40px;
      margin: 2px;
      border-radius: 2px;
      position: relative;
    }

    .book-chaotic {
      background: #e74c3c;
    }

    .book-organized {
      background: #27ae60;
    }

    .fanout-demo {
      background: white;
      border-radius: 15px;
      padding: 25px;
      margin: 25px 0;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border: 3px solid var(--primary-blue);
    }

    .fanout-table {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 8px;
      margin: 20px 0;
    }

    .fanout-entry {
      background: var(--light-gray);
      padding: 12px 8px;
      text-align: center;
      border-radius: 8px;
      font-family: monospace;
      font-size: 0.9em;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .fanout-entry:hover {
      background: var(--accent-orange);
      color: white;
      transform: translateY(-2px);
    }

    .fanout-entry.active {
      background: var(--accent-green);
      color: white;
      font-weight: bold;
    }

    .object-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 20px 0;
    }

    .object-item {
      display: flex;
      align-items: center;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 8px;
      font-family: monospace;
      transition: all 0.3s ease;
    }

    .object-item.highlight {
      background: var(--accent-green);
      color: white;
      transform: scale(1.02);
    }

    .object-index {
      background: var(--secondary-blue);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      margin-right: 12px;
      min-width: 30px;
      text-align: center;
    }

    .pack-format-diagram {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 15px;
      padding: 30px;
      margin: 30px 0;
      overflow: hidden;
    }

    .format-sections {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 20px 0;
    }

    .format-section {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      border-left: 5px solid var(--accent-orange);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .format-section:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateX(10px);
    }

    .format-section h4 {
      margin-bottom: 10px;
      color: var(--accent-orange);
    }

    .binary-search-demo {
      background: white;
      border-radius: 15px;
      padding: 25px;
      margin: 25px 0;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border: 3px solid var(--accent-green);
    }

    .search-steps {
      margin: 20px 0;
    }

    .search-step {
      background: var(--light-gray);
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
      border-left: 4px solid var(--accent-green);
      transition: all 0.3s ease;
    }

    .search-step.active {
      background: var(--accent-green);
      color: white;
      transform: translateX(5px);
    }

    .code-block {
      background: #0d1117;
      color: #c9d1d9;
      padding: 24px;
      border-radius: 8px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.45;
      margin: 20px 0;
      overflow-x: auto;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      border: 1px solid #30363d;
      white-space: pre;
      position: relative;
    }

    .code-block::before {
      content: '‚ö° Go';
      position: absolute;
      top: 8px;
      right: 12px;
      background: #238636;
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
    }

    .code-block .comment {
      color: #7d8590;
      font-style: italic;
    }

    .code-block .keyword {
      color: #ff7b72;
      font-weight: 500;
    }

    .code-block .string {
      color: #a5d6ff;
    }

    .code-block .number {
      color: #79c0ff;
    }

    .code-block .type {
      color: #ffa657;
    }

    .code-block .function {
      color: #d2a8ff;
    }

    .code-block .operator {
      color: #ff7b72;
    }

    .bash-block {
      background: #2d3748;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 8px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      margin: 20px 0;
      overflow-x: auto;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      border: 1px solid #4a5568;
      white-space: pre;
      position: relative;
    }

    .bash-block::before {
      content: '$ bash';
      position: absolute;
      top: 8px;
      right: 12px;
      background: #38a169;
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 500;
    }

    .bash-block .comment {
      color: #a0aec0;
    }

    .bash-block .command {
      color: #68d391;
    }

    .bash-block .string {
      color: #fbb6ce;
    }

    .interactive-demo {
      background: white;
      border-radius: 15px;
      padding: 25px;
      margin: 25px 0;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border: 3px solid var(--accent-red);
    }

    .demo-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .demo-btn {
      background: var(--accent-red);
      color: white;
      padding: 12px 24px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .demo-btn:hover {
      background: #c0392b;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
    }

    .stats-panel {
      background: linear-gradient(135deg, var(--accent-green), #229954);
      color: white;
      border-radius: 15px;
      padding: 25px;
      margin: 25px 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-number {
      font-size: 2.5em;
      font-weight: bold;
      display: block;
    }

    .stat-label {
      opacity: 0.9;
      font-size: 0.9em;
    }

    .callout {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-left: 5px solid var(--accent-orange);
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }

    .callout-icon {
      display: inline-block;
      margin-right: 10px;
      font-size: 1.2em;
    }

    @media (max-width: 768px) {
      .container {
        margin: 10px;
        border-radius: 15px;
      }

      .header {
        padding: 40px 20px;
      }

      .content {
        padding: 20px;
      }

      .library-visual {
        grid-template-columns: 1fr;
      }

      .fanout-table {
        grid-template-columns: repeat(4, 1fr);
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üîì Under the Hood: Unpacking Git's Secrets</h1>
      <div class="subtitle">Part 2: The Pack Index - Git's Brilliant Search
        Engine</div>
    </div>

    <div class="content">
      <div class="section">
        <p>Welcome back to our journey into Git's internals! In <a href="#"
            style="color: var(--primary-blue);">Part 1</a>, we set out to build
          a blazing-fast Git packfile parser in Go. Today, we're tackling the
          first piece of this puzzle: the pack index file (.idx).</p>

        <p>But before we dive into code, let me share a story that perfectly
          illustrates why Git's design is so clever.</p>
      </div>

      <div class="section">
        <h2><span class="icon">üìö</span>The Library Card Catalog Problem</h2>

        <div class="library-analogy">
          <p><strong>Imagine you're in a massive library with millions of books,
              all perfectly organized...</strong></p>

          <div class="library-visual">
            <div class="books-chaotic">
              <h4>‚ùå Without Fanout Table</h4>
              <p><strong>All books alphabetized, but no section guide:</strong>
              </p>
              <div
                style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 5px;">
                <div
                  style="padding: 8px; background: #ffeaa7; border-radius: 4px; font-size: 0.8em;">
                  Aardvark...</div>
                <div
                  style="padding: 8px; background: #ffeaa7; border-radius: 4px; font-size: 0.8em;">
                  Algebra...</div>
                <div
                  style="padding: 8px; background: #ffeaa7; border-radius: 4px; font-size: 0.8em;">
                  ...</div>
                <div
                  style="padding: 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                  Sailing...</div>
                <div
                  style="padding: 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                  Science...</div>
                <div
                  style="padding: 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                  ...</div>
                <div
                  style="padding: 8px; background: #fd79a8; border-radius: 4px; font-size: 0.8em;">
                  Zebra...</div>
              </div>
              <p><strong>Finding "Science":</strong> Binary search through ALL
                books<br>
                <small>üîç Check middle ‚Üí too far ‚Üí go left ‚Üí check middle ‚Üí
                  repeat...</small>
              </p>
            </div>

            <div class="books-organized">
              <h4>‚úÖ With Git's Fanout Table</h4>
              <p><strong>Section directory + alphabetized books:</strong></p>
              <div style="margin: 15px 0;">
                <div
                  style="display: grid; grid-template-columns: 1fr 2fr; gap: 15px;">
                  <div
                    style="background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px;">
                    <strong>üìã Section Guide:</strong><br>
                    <small>A-F: Rack 1-3<br>
                      G-M: Rack 4-7<br>
                      N-S: Rack 8-12<br>
                      T-Z: Rack 13-15</small>
                  </div>
                  <div>
                    <div style="margin: 5px 0;">
                      <strong>Rack 8-12 (N-S):</strong><br>
                      <div style="display: flex; gap: 3px; margin-top: 5px;">
                        <div
                          style="padding: 4px 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                          Navy</div>
                        <div
                          style="padding: 4px 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                          Ocean</div>
                        <div
                          style="padding: 4px 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                          Physics</div>
                        <div
                          style="padding: 4px 8px; background: #00b894; color: white; border-radius: 4px; font-size: 0.8em;">
                          <strong>Science</strong></div>
                        <div
                          style="padding: 4px 8px; background: #fab1a0; border-radius: 4px; font-size: 0.8em;">
                          Space</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <p><strong>Finding "Science":</strong>
                <br>1Ô∏è‚É£ Fanout table ‚Üí "S books are in Rack 8-12"
                <br>2Ô∏è‚É£ Binary search within that rack only! üéØ
              </p>
            </div>
          </div>

          <div class="callout">
            <span class="callout-icon">üí°</span>
            <strong>This is exactly how Git's pack index works!</strong> The
            fanout table tells us "objects starting with 0x45 are in positions
            2-5", then we binary search within just those positions instead of
            the entire pack.
          </div>
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üß†</span>Git's Brilliant Solution: The Pack Index
        </h2>

        <h3>üîç The Magic of the Fanout Table</h3>

        <div class="fanout-demo">
          <p>Here's where Git gets clever. Instead of one giant sorted list, Git
            uses a "fanout table." Let me demonstrate with actual data:</p>

          <h4>Example: 10 Git Objects in Our Pack</h4>
          <div class="object-list" id="objectList">
            <div class="object-item" data-byte="0x12">
              <span class="object-index">[0]</span>
              <span>Hash: <strong>12abcd...</strong> (starts with byte
                0x12)</span>
            </div>
            <div class="object-item" data-byte="0x12">
              <span class="object-index">[1]</span>
              <span>Hash: <strong>12ffff...</strong> (starts with byte
                0x12)</span>
            </div>
            <div class="object-item" data-byte="0x45">
              <span class="object-index">[2]</span>
              <span>Hash: <strong>45abcd...</strong> (starts with byte
                0x45)</span>
            </div>
            <div class="object-item" data-byte="0x45">
              <span class="object-index">[3]</span>
              <span>Hash: <strong>45dead...</strong> (starts with byte
                0x45)</span>
            </div>
            <div class="object-item" data-byte="0x45">
              <span class="object-index">[4]</span>
              <span>Hash: <strong>45feed...</strong> (starts with byte
                0x45)</span>
            </div>
            <div class="object-item" data-byte="0x89">
              <span class="object-index">[5]</span>
              <span>Hash: <strong>89abcd...</strong> (starts with byte
                0x89)</span>
            </div>
            <div class="object-item" data-byte="0xab">
              <span class="object-index">[6]</span>
              <span>Hash: <strong>ababab...</strong> (starts with byte
                0xab)</span>
            </div>
            <div class="object-item" data-byte="0xab">
              <span class="object-index">[7]</span>
              <span>Hash: <strong>abcdef...</strong> (starts with byte
                0xab)</span>
            </div>
            <div class="object-item" data-byte="0xfe">
              <span class="object-index">[8]</span>
              <span>Hash: <strong>fedcba...</strong> (starts with byte
                0xfe)</span>
            </div>
            <div class="object-item" data-byte="0xff">
              <span class="object-index">[9]</span>
              <span>Hash: <strong>ffffff...</strong> (starts with byte
                0xff)</span>
            </div>
          </div>

          <h4>The Fanout Table (256 entries, showing key ones):</h4>
          <div class="fanout-table" id="fanoutTable">
            <div class="fanout-entry" data-byte="0x11"
              onclick="highlightFanout('0x11')">0x11: 0</div>
            <div class="fanout-entry" data-byte="0x12"
              onclick="highlightFanout('0x12')">0x12: 2</div>
            <div class="fanout-entry" data-byte="0x44"
              onclick="highlightFanout('0x44')">0x44: 2</div>
            <div class="fanout-entry" data-byte="0x45"
              onclick="highlightFanout('0x45')">0x45: 5</div>
            <div class="fanout-entry" data-byte="0x88"
              onclick="highlightFanout('0x88')">0x88: 5</div>
            <div class="fanout-entry" data-byte="0x89"
              onclick="highlightFanout('0x89')">0x89: 6</div>
            <div class="fanout-entry" data-byte="0xaa"
              onclick="highlightFanout('0xaa')">0xaa: 6</div>
            <div class="fanout-entry" data-byte="0xab"
              onclick="highlightFanout('0xab')">0xab: 8</div>
          </div>

          <div class="callout">
            <span class="callout-icon">üéØ</span>
            <strong>Click on any fanout entry above</strong> to see which
            objects it covers! Each entry tells us: "How many objects have a
            first byte ‚â§ this value?"
          </div>
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üèóÔ∏è</span>The Pack Index Format</h2>

        <div class="pack-format-diagram">
          <h3 style="color: white; margin-bottom: 20px;">üìã Pack Index File
            Layout</h3>

          <div class="format-sections">
            <div class="format-section">
              <h4>Magic + Version (8 bytes)</h4>
              <p><code>0xff744f63</code> + version number</p>
              <small>Safety check: "Is this really a Git index file?"</small>
            </div>

            <div class="format-section">
              <h4>Fanout Table (1024 bytes)</h4>
              <p>256 √ó 4-byte integers</p>
              <small>Our search accelerator - tells us where to look!</small>
            </div>

            <div class="format-section">
              <h4>SHA-1 Hashes (20 √ó N bytes)</h4>
              <p>All object hashes, sorted lexicographically</p>
              <small>The actual object identifiers we're searching for</small>
            </div>

            <div class="format-section">
              <h4>CRC-32 Values (4 √ó N bytes)</h4>
              <p>Checksums for data integrity</p>
              <small>Verify objects haven't been corrupted</small>
            </div>

            <div class="format-section">
              <h4>32-bit Offsets (4 √ó N bytes)</h4>
              <p>Where each object lives in the .pack file</p>
              <small>The treasure map to find actual object data!</small>
            </div>

            <div class="format-section">
              <h4>Large Offset Table (Optional)</h4>
              <p>64-bit offsets for huge packs (>2GB)</p>
              <small>Because some repositories are REALLY big</small>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üîç</span>The Two-Step Search Process</h2>

        <div class="binary-search-demo">
          <h3>Finding Object <code>45dead...</code> Step by Step</h3>

          <div class="search-steps">
            <div class="search-step">
              <strong>Step 1:</strong> Extract first byte: <code>0x45</code>
            </div>
            <div class="search-step">
              <strong>Step 2:</strong> Fanout lookup: "Objects with 0x45 are in
              positions 2-4"
              <br><small>üèÉ‚Äç‚ôÇÔ∏è Jump directly to the right "rack" - no scanning
                needed!</small>
            </div>
            <div class="search-step">
              <strong>Step 3:</strong> Binary search within positions [2,3,4]
              <br><small>üìñ Books are alphabetized within the rack</small>
            </div>
            <div class="search-step">
              <strong>Step 4:</strong> Check middle position (3): Found
              <code>45dead...</code>!
              <br><small>üéØ Just 1 comparison instead of potentially 10!</small>
            </div>
          </div>

          <div class="code-block"><span class="keyword">func</span> (<span
              class="type">f</span> <span class="operator">*</span><span
              class="type">idxFile</span>) <span
              class="function">findObject</span>(<span
              class="type">targetHash</span> <span class="type">Hash</span>)
            (<span class="type">offset</span> <span
              class="keyword">uint64</span>, <span class="type">found</span>
            <span class="keyword">bool</span>) {
            <span class="comment">// Step 1: Extract the first byte of our
              target hash</span>
            <span class="type">firstByte</span> <span class="operator">:=</span>
            <span class="type">targetHash</span>[<span class="number">0</span>]

            <span class="comment">// Step 2: Use fanout to narrow our search
              range</span>
            <span class="type">searchStart</span> <span
              class="operator">:=</span> <span
              class="keyword">uint32</span>(<span class="number">0</span>)
            <span class="keyword">if</span> <span class="type">firstByte</span>
            <span class="operator">></span> <span class="number">0</span> {
            <span class="type">searchStart</span> <span
              class="operator">=</span> <span class="type">f</span>.<span
              class="type">fanout</span>[<span
              class="type">firstByte</span><span class="operator">-</span><span
              class="number">1</span>]
            }
            <span class="type">searchEnd</span> <span class="operator">:=</span>
            <span class="type">f</span>.<span class="type">fanout</span>[<span
              class="type">firstByte</span>]

            <span class="comment">// Step 3: Binary search within our narrowed
              range</span>
            <span class="type">left</span> <span class="operator">:=</span>
            <span class="keyword">int</span>(<span
              class="type">searchStart</span>) <span class="comment">// 2</span>
            <span class="type">right</span> <span class="operator">:=</span>
            <span class="keyword">int</span>(<span
              class="type">searchEnd</span>) <span class="operator">-</span>
            <span class="number">1</span> <span class="comment">// 4</span>

            <span class="keyword">for</span> <span class="type">left</span>
            <span class="operator">
              <=< /span> <span class="type">right</span> {
                <span class="type">mid</span> <span class="operator">:=</span>
                (<span class="type">left</span> <span class="operator">+</span>
                <span class="type">right</span>) <span class="operator">/</span>
                <span class="number">2</span>
                <span class="type">cmp</span> <span class="operator">:=</span>
                bytes.<span class="function">Compare</span>(<span
                  class="type">f</span>.<span class="type">oidTable</span>[<span
                  class="type">mid</span>][:], <span
                  class="type">targetHash</span>[:])
                <span class="keyword">if</span> <span class="type">cmp</span>
                <span class="operator">==</span> <span class="number">0</span> {
                <span class="keyword">return</span> <span
                  class="type">f</span>.<span class="type">entries</span>[<span
                  class="type">mid</span>].<span class="type">offset</span>,
                <span class="keyword">true</span> <span class="comment">// Found
                  it!</span>
                } <span class="keyword">else if</span> <span
                  class="type">cmp</span> <span class="operator">
                  << /span> <span class="number">0</span> {
                    <span class="type">left</span> <span
                      class="operator">=</span> <span class="type">mid</span>
                    <span class="operator">+</span> <span
                      class="number">1</span> <span class="comment">// Target is
                      in upper half</span>
                    } <span class="keyword">else</span> {
                    <span class="type">right</span> <span
                      class="operator">=</span> <span class="type">mid</span>
                    <span class="operator">-</span> <span
                      class="number">1</span> <span class="comment">// Target is
                      in lower half</span>
                    }
                    }

                    <span class="keyword">return</span> <span
                      class="number">0</span>, <span
                      class="keyword">false</span> <span class="comment">// Not
                      found</span>
                    }
          </div>

          <div class="stats-panel">
            <div class="stat-item">
              <span class="stat-number">70%</span>
              <span class="stat-label">Search Space Reduced</span>
            </div>
            <div class="stat-item">
              <span class="stat-number">1</span>
              <span class="stat-label">Comparison Needed</span>
            </div>
            <div class="stat-item">
              <span class="stat-number">vs 10</span>
              <span class="stat-label">Without Fanout</span>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">‚öôÔ∏è</span>Parsing the Index - Step by Step</h2>

        <p>Let's parse the index file, explaining each step as we go:</p>

        <h3>üîç Step 1: Verify the File Header</h3>
        <div class="code-block"><span class="keyword">func</span> <span
            class="function">parseIdx</span>(<span class="type">ix</span> <span
            class="operator">*</span>mmap.<span class="type">ReaderAt</span>)
          (<span class="operator">*</span><span class="type">idxFile</span>,
          <span class="keyword">error</span>) {
          <span class="comment">// Step 1: Verify this is actually a Git index
            file</span>
          <span class="type">header</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span class="keyword">byte</span>,
          <span class="number">8</span>)
          <span class="type">ix</span>.<span
            class="function">ReadAt</span>(<span class="type">header</span>,
          <span class="number">0</span>)

          <span class="comment">// The magic bytes spell "√øtOc" (0xff744f63) -
            Git's signature</span>
          <span class="keyword">if</span> <span
            class="operator">!</span>bytes.<span
            class="function">Equal</span>(<span class="type">header</span>[<span
            class="number">0</span>:<span class="number">4</span>], []<span
            class="keyword">byte</span>{<span class="number">0xff</span>, <span
            class="number">0x74</span>, <span class="number">0x4f</span>, <span
            class="number">0x63</span>}) {
          <span class="keyword">return</span> <span class="keyword">nil</span>,
          fmt.<span class="function">Errorf</span>(<span class="string">"not a
            Git pack index file"</span>)
          }

          <span class="comment">// We only understand version 2 (the current
            standard)</span>
          <span class="type">version</span> <span class="operator">:=</span>
          binary.BigEndian.<span class="function">Uint32</span>(<span
            class="type">header</span>[<span class="number">4</span>:<span
            class="number">8</span>])
          <span class="keyword">if</span> <span class="type">version</span>
          <span class="operator">!=</span> <span class="number">2</span> {
          <span class="keyword">return</span> <span class="keyword">nil</span>,
          fmt.<span class="function">Errorf</span>(<span
            class="string">"unsupported version %d"</span>, <span
            class="type">version</span>)
          }
        </div>

        <div class="callout">
          <span class="callout-icon">üõ°Ô∏è</span>
          <strong>Why these magic bytes?</strong> Git uses them as a safety
          check. If you accidentally try to parse a JPEG as a pack index, this
          check saves you immediately!
        </div>

        <h3>üìä Step 2: Read the Fanout Table</h3>
        <div class="code-block"> <span class="comment">// Step 2: Read the
            fanout table</span>
          <span class="type">fanout</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span
            class="keyword">uint32</span>, <span class="number">256</span>)
          <span class="type">fanoutData</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span class="keyword">byte</span>,
          <span class="number">1024</span>) <span class="comment">// 256 √ó 4
            bytes</span>
          <span class="type">ix</span>.<span
            class="function">ReadAt</span>(<span class="type">fanoutData</span>,
          <span class="number">8</span>) <span class="comment">// Right after
            the header</span>

          <span class="comment">// Convert from bytes to integers (Git uses
            big-endian)</span>
          <span class="keyword">for</span> <span class="type">i</span> <span
            class="operator">:=</span> <span class="number">0</span>; <span
            class="type">i</span> <span class="operator">
            << /span> <span class="number">256</span>; <span
                class="type">i</span><span class="operator">++</span> {
              <span class="type">offset</span> <span class="operator">:=</span>
              <span class="type">i</span> <span class="operator">*</span> <span
                class="number">4</span>
              <span class="type">fanout</span>[<span class="type">i</span>]
              <span class="operator">=</span> binary.BigEndian.<span
                class="function">Uint32</span>(<span
                class="type">fanoutData</span>[<span
                class="type">offset</span>:<span class="type">offset</span><span
                class="operator">+</span><span class="number">4</span>])
              }

              <span class="comment">// The last fanout entry tells us the total
                object count!</span>
              <span class="type">objectCount</span> <span
                class="operator">:=</span> <span
                class="type">fanout</span>[<span class="number">255</span>]
              fmt.<span class="function">Printf</span>(<span
                class="string">"This pack contains %d objects\n"</span>, <span
                class="type">objectCount</span>)
        </div>

        <div class="callout">
          <span class="callout-icon">üî¢</span>
          <strong>Big-endian format:</strong> Git stores numbers in "big-endian"
          format (most significant byte first). This is like writing "2024"
          instead of "4202". We need to convert this to our computer's native
          format.
        </div>

        <h3>üìç Step 3: Calculate Section Positions</h3>
        <div class="code-block"> <span class="comment">// Step 3: Calculate
            where each section starts</span>
          <span class="comment">// This is just arithmetic, but it's crucial to
            get right!</span>
          <span class="type">hashTableStart</span> <span
            class="operator">:=</span> <span class="keyword">int64</span>(<span
            class="number">8</span> <span class="operator">+</span> <span
            class="number">1024</span>) <span class="comment">// After header +
            fanout</span>
          <span class="type">crcTableStart</span> <span
            class="operator">:=</span> <span class="type">hashTableStart</span>
          <span class="operator">+</span> <span
            class="keyword">int64</span>(<span class="type">objectCount</span>
          <span class="operator">*</span> <span class="number">20</span>)
          <span class="type">offsetTableStart</span> <span
            class="operator">:=</span> <span class="type">crcTableStart</span>
          <span class="operator">+</span> <span
            class="keyword">int64</span>(<span class="type">objectCount</span>
          <span class="operator">*</span> <span class="number">4</span>)
        </div>

        <h3>üîó Step 4: Read Object Hashes</h3>
        <div class="code-block"> <span class="comment">// Step 4: Read all the
            hashes</span>
          <span class="type">hashes</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span class="type">Hash</span>,
          <span class="type">objectCount</span>)
          <span class="type">hashData</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span class="keyword">byte</span>,
          <span class="type">objectCount</span> <span class="operator">*</span>
          <span class="number">20</span>)
          <span class="type">ix</span>.<span
            class="function">ReadAt</span>(<span class="type">hashData</span>,
          <span class="type">hashTableStart</span>)

          <span class="comment">// Split the continuous byte stream into
            individual hashes</span>
          <span class="keyword">for</span> <span class="type">i</span> <span
            class="operator">:=</span> <span class="keyword">uint32</span>(<span
            class="number">0</span>); <span class="type">i</span> <span
            class="operator">
            << /span> <span class="type">objectCount</span>; <span
                class="type">i</span><span class="operator">++</span> {
              <span class="keyword">copy</span>(<span
                class="type">hashes</span>[<span class="type">i</span>][:],
              <span class="type">hashData</span>[<span
                class="type">i</span><span class="operator">*</span><span
                class="number">20</span>:(<span class="type">i</span><span
                class="operator">+</span><span class="number">1</span>)<span
                class="operator">*</span><span class="number">20</span>])
              }
        </div>

        <div class="callout">
          <span class="callout-icon">üî§</span>
          <strong>Why are the hashes stored sorted?</strong> This enables binary
          search! With a million objects, we can find any object in just 20
          comparisons instead of potentially checking all million.
        </div>

        <h3>üóÇÔ∏è Step 5: Handle Large Packfiles (The 2GB Challenge)</h3>
        <p>Here's an interesting problem: The offset table uses 32-bit integers,
          which can only represent numbers up to about 4 billion. But packfiles
          can be larger than 4GB!</p>

        <div class="code-block"> <span class="comment">// Step 5: Read the
            offset table</span>
          <span class="type">entries</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span
            class="type">idxEntry</span>, <span class="type">objectCount</span>)
          <span class="type">offsetData</span> <span class="operator">:=</span>
          <span class="keyword">make</span>([]<span class="keyword">byte</span>,
          <span class="type">objectCount</span> <span class="operator">*</span>
          <span class="number">4</span>)
          <span class="type">ix</span>.<span
            class="function">ReadAt</span>(<span class="type">offsetData</span>,
          <span class="type">offsetTableStart</span>)

          <span class="keyword">var</span> <span
            class="type">largeOffsetRefs</span> []<span
            class="keyword">struct</span> {
          <span class="type">objIndex</span> <span class="keyword">uint32</span>
          <span class="type">largeIndex</span> <span
            class="keyword">uint32</span>
          }

          <span class="keyword">for</span> <span class="type">i</span> <span
            class="operator">:=</span> <span class="keyword">uint32</span>(<span
            class="number">0</span>); <span class="type">i</span> <span
            class="operator">
            << /span> <span class="type">objectCount</span>; <span
                class="type">i</span><span class="operator">++</span> {
              <span class="type">offset32</span> <span
                class="operator">:=</span> binary.BigEndian.<span
                class="function">Uint32</span>(<span
                class="type">offsetData</span>[<span class="type">i</span><span
                class="operator">*</span><span class="number">4</span>:(<span
                class="type">i</span><span class="operator">+</span><span
                class="number">1</span>)<span class="operator">*</span><span
                class="number">4</span>])

              <span class="keyword">if</span> <span
                class="type">offset32</span><span class="operator">&</span><span
                class="number">0x80000000</span> <span
                class="operator">==</span> <span class="number">0</span> {
              <span class="comment">// Normal offset - use it directly</span>
              <span class="type">entries</span>[<span
                class="type">i</span>].<span class="type">offset</span> <span
                class="operator">=</span> <span
                class="keyword">uint64</span>(<span
                class="type">offset32</span>)
              } <span class="keyword">else</span> {
              <span class="comment">// MSB is set - this is a large offset
                reference</span>
              <span class="type">largeIndex</span> <span
                class="operator">:=</span> <span class="type">offset32</span>
              <span class="operator">&</span> <span
                class="number">0x7FFFFFFF</span>
              <span class="type">largeOffsetRefs</span> <span
                class="operator">=</span> <span
                class="keyword">append</span>(<span
                class="type">largeOffsetRefs</span>, <span
                class="keyword">struct</span>{
              <span class="type">objIndex</span> <span
                class="keyword">uint32</span>
              <span class="type">largeIndex</span> <span
                class="keyword">uint32</span>
              }{<span class="type">i</span>, <span
                class="type">largeIndex</span>})
              }
              }
        </div>

        <div class="callout">
          <span class="callout-icon">üß†</span>
          <strong>The clever trick:</strong> If the most significant bit is 1,
          the remaining 31 bits aren't an offset - they're an index into a
          separate "large offset" table at the end of the file. This elegantly
          handles huge repositories!
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üîß</span>Putting It All Together</h2>

        <p>Now we can build our complete store that opens multiple packfiles:
        </p>

        <div class="code-block"><span class="keyword">func</span> <span
            class="function">Open</span>(<span class="type">dir</span> <span
            class="keyword">string</span>) (<span class="operator">*</span><span
            class="type">Store</span>, <span class="keyword">error</span>) {
          <span class="comment">// Find all packfiles</span>
          <span class="type">packPaths</span>, <span class="type">_</span> <span
            class="operator">:=</span> filepath.<span
            class="function">Glob</span>(filepath.<span
            class="function">Join</span>(<span class="type">dir</span>, <span
            class="string">"*.pack"</span>))

          <span class="type">store</span> <span class="operator">:=</span> <span
            class="operator">&</span><span class="type">Store</span>{
          <span class="type">index</span>: <span
            class="keyword">make</span>(<span class="keyword">map</span>[<span
            class="type">Hash</span>]<span class="type">ref</span>),
          }

          <span class="keyword">for</span> <span class="type">packID</span>,
          <span class="type">packPath</span> <span class="operator">:=</span>
          <span class="keyword">range</span> <span class="type">packPaths</span>
          {
          <span class="comment">// Memory-map both files for efficiency</span>
          <span class="type">packFile</span>, <span class="type">_</span> <span
            class="operator">:=</span> mmap.<span
            class="function">Open</span>(<span class="type">packPath</span>)
          <span class="type">idxPath</span> <span class="operator">:=</span>
          strings.<span class="function">TrimSuffix</span>(<span
            class="type">packPath</span>, <span class="string">".pack"</span>)
          <span class="operator">+</span> <span class="string">".idx"</span>
          <span class="type">idxFile</span>, <span class="type">_</span> <span
            class="operator">:=</span> mmap.<span
            class="function">Open</span>(<span class="type">idxPath</span>)

          <span class="comment">// Parse the index</span>
          <span class="type">idx</span>, <span class="type">_</span> <span
            class="operator">:=</span> <span
            class="function">parseIdx</span>(<span class="type">idxFile</span>)

          <span class="comment">// Build our global object map</span>
          <span class="keyword">for</span> <span class="type">i</span>, <span
            class="type">hash</span> <span class="operator">:=</span> <span
            class="keyword">range</span> <span class="type">idx</span>.<span
            class="type">oidTable</span> {
          <span class="type">store</span>.<span class="type">index</span>[<span
            class="type">hash</span>] <span class="operator">=</span> <span
            class="type">ref</span>{
          <span class="type">packID</span>: <span class="type">packID</span>,
          <span class="type">offset</span>: <span class="type">idx</span>.<span
            class="type">entries</span>[<span class="type">i</span>].<span
            class="type">offset</span>,
          }
          }
          }

          <span class="keyword">return</span> <span class="type">store</span>,
          <span class="keyword">nil</span>
          }
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üß™</span>Testing Our Implementation</h2>

        <p>Let's verify our code works with a real example:</p>

        <div class="code-block"><span class="keyword">func</span> <span
            class="function">main</span>() {
          <span class="type">store</span>, <span class="type">_</span> <span
            class="operator">:=</span> <span class="function">Open</span>(<span
            class="string">".git/objects/pack"</span>)

          <span class="comment">// Try to find a known object</span>
          <span class="type">hash</span>, <span class="type">_</span> <span
            class="operator">:=</span> <span
            class="function">ParseHash</span>(<span
            class="string">"45dead0000000000000000000000000000000000"</span>)

          <span class="keyword">if</span> <span class="type">ref</span>, <span
            class="type">found</span> <span class="operator">:=</span> <span
            class="type">store</span>.<span class="type">index</span>[<span
            class="type">hash</span>]; <span class="type">found</span> {
          fmt.<span class="function">Printf</span>(<span class="string">"Found
            object in pack %d at offset %d\n"</span>,
          <span class="type">ref</span>.<span class="type">packID</span>, <span
            class="type">ref</span>.<span class="type">offset</span>)
          }
          }
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üß™</span>Try It Yourself!</h2>

        <p>Want to see this in action? Here's a challenge:</p>

        <div class="code-block">
          <span class="comment"># Create a test repository</span>
          git init test-repo
          cd test-repo
          echo <span class="string">"Hello Git!"</span> > file.txt
          git add . && git commit -m <span class="string">"First commit"</span>

          <span class="comment"># Force Git to create a packfile</span>
          git gc

          <span class="comment"># Examine the pack index</span>
          git verify-pack -v .git/objects/pack/*.idx

          <span class="comment"># Now run our Go code on this repository!</span>
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üöÄ</span>Performance: Why This Design Is
          Brilliant</h2>

        <div class="stats-panel">
          <div class="stat-item">
            <span class="stat-number">10M</span>
            <span class="stat-label">Objects in Large Repo</span>
          </div>
          <div class="stat-item">
            <span class="stat-number">23</span>
            <span class="stat-label">Comparisons Without Fanout</span>
          </div>
          <div class="stat-item">
            <span class="stat-number">15</span>
            <span class="stat-label">Comparisons With Fanout</span>
          </div>
          <div class="stat-item">
            <span class="stat-number">35%</span>
            <span class="stat-label">Improvement!</span>
          </div>
        </div>

        <div class="callout">
          <span class="callout-icon">‚ö°</span>
          <strong>Memory efficiency:</strong> Just 44 bytes per object (20 for
          hash + 4 for CRC + 4 for offset + overhead). That's incredibly compact
          for such powerful functionality!
        </div>

        <h3>üìà What We've Learned</h3>
        <p>We've not only parsed Git's pack index but understood <em>why</em>
          it's designed this way:</p>

        <ul style="margin: 20px 0; padding-left: 20px;">
          <li><strong>The fanout table</strong> dramatically reduces search
            space (like library section guides)</li>
          <li><strong>Sorted hashes</strong> enable efficient binary search
            within sections</li>
          <li><strong>Memory mapping</strong> avoids copying gigabytes of data
          </li>
          <li><strong>Parallel arrays</strong> keep related data together for
            cache efficiency</li>
          <li><strong>Large offset handling</strong> gracefully supports huge
            repositories</li>
        </ul>
      </div>

      <div class="section">
        <h2><span class="icon">üíæ</span>Core Data Structures</h2>

        <p>Before we dive into parsing, let's understand what we're building:
        </p>

        <div class="code-block"><span class="comment">// idxFile represents a
            parsed Git pack index file</span>
          <span class="keyword">type</span> <span class="type">idxFile</span>
          <span class="keyword">struct</span> {
          <span class="comment">// The sorted list of all object hashes in this
            pack</span>
          <span class="comment">// Think of this as the library's sorted card
            catalog</span>
          <span class="type">oidTable</span> []<span class="type">Hash</span>

          <span class="comment">// Parallel array containing the location of
            each object</span>
          <span class="comment">// If oidTable[5] is hash X, then entries[5]
            tells us where X lives</span>
          <span class="type">entries</span> []<span class="type">idxEntry</span>

          <span class="comment">// The fanout table we just discussed - our
            search accelerator!</span>
          <span class="type">fanout</span> [<span
            class="number">256</span>]<span class="keyword">uint32</span>

          <span class="comment">// For huge repositories (>2GB packs), some
            offsets don't fit</span>
          <span class="comment">// in 32 bits, so we need this overflow
            table</span>
          <span class="type">largeOffsets</span> []<span
            class="keyword">uint64</span>
          }

          <span class="keyword">type</span> <span class="type">idxEntry</span>
          <span class="keyword">struct</span> {
          <span class="type">offset</span> <span class="keyword">uint64</span>
          <span class="comment">// Where in the .pack file this object
            starts</span>
          <span class="type">crc</span> <span class="keyword">uint32</span>
          <span class="comment">// Checksum to verify the object isn't
            corrupted</span>
          }
        </div>
      </div>

      <div class="section">
        <h2><span class="icon">üîÆ</span>Coming Up Next</h2>

        <p>We can now find any object in a packfile, but we haven't actually
          read the object data yet. In <strong>Part 3</strong>, we'll dive into
          the packfile format itself, learning how to:</p>

        <ul style="margin: 20px 0; padding-left: 20px;">
          <li>Parse object headers and extract metadata</li>
          <li>Decompress data with zlib compression</li>
          <li>Handle Git's clever delta compression system</li>
          <li>Resolve complex delta chains efficiently</li>
        </ul>

        <div class="callout">
          <span class="callout-icon">üéØ</span>
          <strong>The real magic of Git's storage efficiency is just beginning
            to reveal itself!</strong> We've built the index to find objects
          quickly, but the packfile itself contains the compressed,
          delta-encoded data that makes Git so space-efficient.
        </div>
      </div>
    </div>
  </div>

  <script>
    function highlightFanout(byte) {
      // Reset all highlights
      document.querySelectorAll('.fanout-entry').forEach(entry => {
        entry.classList.remove('active');
      });
      document.querySelectorAll('.object-item').forEach(item => {
        item.classList.remove('highlight');
      });

      // Highlight clicked fanout entry
      document.querySelector(`[data-byte="${byte}"]`).classList.add('active');

      // Highlight corresponding objects
      const byteValue = parseInt(byte.replace('0x', ''), 16);
      document.querySelectorAll('.object-item').forEach((item, index) => {
        const itemByte = item.getAttribute('data-byte');
        const itemByteValue = parseInt(itemByte.replace('0x', ''), 16);

        if (itemByteValue <= byteValue) {
          item.classList.add('highlight');
        }
      });
    }

    // Add some interactive hover effects
    document.querySelectorAll('.object-item').forEach(item => {
      item.addEventListener('mouseenter', function () {
        if (!this.classList.contains('highlight')) {
          this.style.backgroundColor = '#e8f4f8';
        }
      });

      item.addEventListener('mouseleave', function () {
        if (!this.classList.contains('highlight')) {
          this.style.backgroundColor = '';
        }
      });
    });
  </script>
</body>

</html>
